<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/myicon.png"><link rel="icon" href="/img/myicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="hff"><meta name="keywords" content=""><meta name="description" content="关于JVM学习的阶段性总结"><meta property="og:type" content="article"><meta property="og:title" content="JVM-1:JVM整体结构以及类加载器"><meta property="og:url" content="http://www.hff.ink/2023/04/08/jvm%E6%80%BB%E7%BB%93-1/index.html"><meta property="og:site_name" content="Hff’s Blog"><meta property="og:description" content="关于JVM学习的阶段性总结"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-04-07T16:00:00.000Z"><meta property="article:modified_time" content="2023-04-09T01:39:24.291Z"><meta property="article:author" content="HFF"><meta property="article:tag" content="底层"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary_large_image"><title>JVM-1:JVM整体结构以及类加载器 - Hff’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.hff.ink",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"left",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hff&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/tetons-at-night.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="JVM-1:JVM整体结构以及类加载器"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> hff </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-08 00:00" pubdate>2023年4月8日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 51 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="padding-left:2rem;margin-right:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">JVM-1:JVM整体结构以及类加载器</h1><div class="markdown-body"><div class="note note-success"><p>对于Java程序员来说，JAVA虚拟机底层的指令，不是我们核心关注的内容，我们关注的是我们写的java程序在jvm中运行时需要的内存，内存是由JVM自动管理的，由于程序或硬件的原因可能会出现内存泄漏或溢出的问题导致运行的程序崩溃，不了解JVM的内存结构和各个内存区域的工作职责，将对解决这类问题带来很大的麻烦，所以学习java到一定程度的时候，是必须要学习jvm里的知识点的</p><p>关于JVM，其实有很多大厂开发了不同版本的JVM，比较知名的有：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、 Azul VM、 Apache Harmony、 Google Dalvik VM、 Microsoft JVM等等。</p><p>现在使用的比较多的JDK8版本就是Sun HotSpot VM与BEA JRockit VM合并之后开发出的JDK版本。</p><p>JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。所以，JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE，JRE又包含了JVM。</p></div><h2 id="jvm的整体结构">jvm的整体结构</h2><pre><code class="mermaid">flowchart TD
    subgraph &quot; &quot;
        direction LR
            f[CLass files] --&gt; c[Class Loader]
    end    
    subgraph runtime [运行时数据区]
        subgraph private [线程共享]
    	    method[方法区]
            stack[堆] 
        end
        subgraph public[线程私有]
            heap[栈] 
            native[本地方法栈]
            count[程序计数器]
        end
    end
    subgraph a[ ]
        direction LR
            subgraph 执行引擎
                解释器
                subgraph JIT编译器
                    中间代码生成器
                    代码优化器
                    目标代码生成器
                    分析器
                end
                垃圾回收器
            end
           
            subgraph 本地方法接口
                JNI
            end
            
            subgraph 本地方法库
                NativeMethodLibrary
            end
            执行引擎&lt;--&gt;本地方法接口
            本地方法接口&lt;--&gt;本地方法库
    end
    c--&gt;runtime
    runtime &lt;--&gt; a
</code></pre><h3 id="运行时数据区">运行时数据区</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><h4 id="线程共享">线程共享</h4><h5 id="方法区">方法区</h5><p>存放类的元数据(类，接口，属性，方法…)，<strong>静态变量+常量+类信息(构造方法/接口定义)+运行时常量池</strong>存在方法区中但是<strong>实例变量存在堆内存</strong>中,和方法区无关。</p><ul><li><strong>常量池</strong>：常量池是方法区的一部分，Class文件中除了类的基本信息还有类的常量池表，用于存放编译期生成的字面量与符号引用，这些内容将被加载到常量池中。</li></ul><h5 id="堆">堆</h5><p>存放对象实例，new出来的对象都会在堆中分配内存，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法</strong>都是在函数的栈内存中分配。</p><h4 id="线程私有">线程私有</h4><h5 id="栈-虚拟机栈">栈(虚拟机栈)</h5><p>描述Java方法执行的线程内存模型，每个方法被执行时，虚拟机都会同步创建一个栈帧<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。每一个方法被调用直至执行结束，都对应一个栈帧出栈到入栈的过程。</p><p>栈又分为三个子实体：</p><ul><li><p><strong>局部变量表</strong> —— 与方法相关，涉及局部变量，并在此存储相应的值。</p></li><li><p><strong>操作数栈</strong> —— 如果需要执行任何中间操作，操作数栈将充当运行时工作空间来执行操作。</p></li><li><p><strong>帧数据</strong> —— 对应于方法的所有符号存储在此处。在任何异常的情况下，捕获的区块信息将被保持在帧数据中。</p></li></ul><h5 id="本地方法栈">本地方法栈</h5><p>本地方法栈的作用与虚拟机栈的作用类似，不同的是本地方法栈是为本地方法所服务，它的具体做法是<code>本地方法栈中</code>登记为<code>本地方法</code>，在<code>执行引擎</code>执行时加载<code>本地方法库</code>。</p><h5 id="程序计数器">程序计数器</h5><p>当前线程执行的字节码的行号指示器，就是一个指针。字节码解释器工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理和线程恢复等功能都依赖于它来完成，是一个非常小的内存空间，几乎可以忽略不记。</p><h3 id="执行引擎">执行引擎</h3><p>分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐个执行它。</p><ul><li><p><strong>解释器</strong>：读取字节码，对其进行解释并逐一执行。解释器解释字节码的速度较快，但执行速度较慢。解释器的缺点是，当一个方法多次调用时，每次都需要解释。</p></li><li><p><strong>JIT编译器</strong>：JIT编译器消除了解释器的缺点（当一个方法多次调用时，每次都需要解释），执行引擎将使用解释器的帮助进行转换，当发现重复的代码时，它将使用JIT编译器编译整个字节码并将其更改为本地代码。此本地代码将直接用于重复的方法调用，从而提高系统性能。</p><ul><li>中间代码生成器 —— 生成中间代码。</li><li>代码优化器 —— 代码优化器负责优化上面生成的中间代码。</li><li>目标代码生成器 —— 目标代码生成器负责生成机器代码/本机代码。</li><li>分析器 —— 一个特殊组件，负责查找热点，即该方法是否被多次调用。</li></ul></li><li><p><strong>垃圾回收器</strong>：垃圾回收器是执行引擎的一部分，它收集/删除未引用的对象。可以通过调用<code>System.gc()</code>来触发垃圾回收，但是不能保证执行。JVM的垃圾收集器仅收集那些由new关键字创建的对象（无论以哪种方式创建对象，最终也是会回到new关键字上，只是不是我们显式地使用关键字new创建而已）。因此，如果创建了没有new的任何对象，则可以使用<code>finalize</code>方法执行清理。</p></li></ul><h3 id="本地方法接口">本地方法接口</h3><p>本地方法接口(JNI)将与本机方法库进行交互，并提供执行引擎所需的本机库。</p><h3 id="本地方法库">本地方法库</h3><p>它是执行引擎所需的本机库的集合。</p><p><font color="blue">JDK1.7和JDK1.8的运行时数据区的区别？（永久代<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和元空间<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>）</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">JDK1.8以前的HotSpot JVM有方法区，也叫永久代(permanent generation,PermGen space,PermGen)。<br>    <br>方法区用于存放已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码。<br>    <br>方法区是一片连续的堆空间，通过-XX:MaxPermSize来设定永久代最大可分配空间，当JVM加载的类信息容量超过了这个值，会报OOM:PermGen错误。<br>    <br>永久代的GC是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集。<br>    <br>移除永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)、类的静态变量转移到了Java heap。<br>    <br>JDK1.8 和 JDK1.7的jvm内存最大的区别是：在1.8中方法区是由元空间(元数据区)来实现的，常量池移到堆中。1.8不存在方法区，将方法区的实现给去掉了，而是在本地内存中,新加入元数据区(元空间)。<br>    <br>元空间：存储 .class 信息， 类的信息，方法的定义，静态变量等，而常量池放到堆里存储。<br><br>JDK8时，永久代已被移除，所以不支持 -XX:PermSize=10M -XX:MaxPermSize=10M 永久代的参数设置。<br>JDK8 的方法区是 元空间，其参数设置是 -XX:MetaspaceSize=N -XX:MaxMetaspaceSize=N。<br><br>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用 本地内存。默认情况下，元空间的大小仅受 本地内存 限制，但可以通过参数来指定元空间的大小。<br></code></pre></td></tr></table></figure><p><font color="blue">为什么要用元空间替代方法区？</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中就容易出现内存溢出，设置大了又浪费内存。<br></code></pre></td></tr></table></figure><h2 id="类加载器ClassLoader">类加载器ClassLoader</h2><h3 id="类的加载过程">类的加载过程</h3><pre><code class="mermaid">flowchart TD
	subgraph 连接Linking
		验证Verification--&gt;准备Preparation--&gt;解析Resolution
	end
	加载Loading--&gt;连接Linking--&gt;初始化Initialization--&gt;使用Using--&gt;卸载Unloading
</code></pre><p>类加载过程包括：加载，连接，初始化，使用和卸载，其中连接阶段又可以分为验证，准备和解析。这其中除了解析阶段，其他阶段的顺序都是固定的，解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定(动态绑定)，以此实现Java的继承和多态。</p><h4 id="加载">加载</h4><p>加载阶段是将<code>.class</code>文件加载到<code>classLoader</code>中，并创建一个<code>Class</code>对象。</p><p>在加载阶段，jvm需要做以下三件事情：</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的的静态存储结构转换为方法区的运行时数据结构</li><li>在堆内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的访问入口。</li></ul><h4 id="验证">验证</h4><p>此时文件字节流已经被获取到，需要将<code>.class</code>文件中的类数据转换为方法区的运行时数据结构，但是先需要验证文件中信息是否符合当前虚拟机规范。按照虚拟机规范，如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个<code>java.lang.VerifyError</code>异常或其子类异常。</p><h4 id="准备">准备</h4><p>为类的静态变量分配内存空间，并且初始化为默认值。而如果变量被<code>final static</code>修饰，并且类型<code>ConstantValue</code><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>时，在准备阶段就将变量设置成该值。而<code>final</code>单独修饰的变量则在初始化时进行赋值。</p><h4 id="解析">解析</h4><p>解析阶段是将常量池中符号引用替换为直接引用的过程，根据符号引用的信息，在类或接口的运行时常量池中查找对应的直接引用，如果直接引用不存在，则需要通过其他方式生成直接引用，比如类或者接口的初始化方法，或者父类父接口的初始化方法。</p><h4 id="初始化">初始化</h4><p>这是类加载的最后阶段，此处所有静态变量将被分配原始值，并且将执行静态块。</p><p><font color="blue">父类和子类的初始化顺序？</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">父类静态块→子类静态块→父类初始化块（成员变量，非静态代码块等）→父类构造方法→子类初始化块（成员变量，非静态代码块等）→子类构造方法<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><p>这里类加载完成之后就可以进行使用了，上面说到的都是静态变量，代码块的初始化赋值执行操作，那么类的成员变量，类的构造方法呢？这些叫做<code>init</code>方法执行构造方法，完成类成员变量的初始化（也就是实例变量），当然这些都是在创建完对象后进行的操作，而且<code>init</code>执行前需要显示的去执行父类的<code>init</code>方法。</p><h4 id="卸载">卸载</h4><p>类型卸载的条件比较严苛，具备以下条件的类才可以被卸载</p><ul><li>该类的所有对象都已被清除。</li><li>该类的<code>java.lang.Class</code>对象没有被任何对象或变量引用。只要一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：<code>java.lang.Class</code>。这个对象在类被加载进方法区的时候创建，在方法区中该类被删除时清除。</li><li>加载该类的<code>ClassLoader</code>已经被回收。</li></ul><h3 id="双亲委派模型">双亲委派模型</h3><p>Java中的类加载器分为四种，前三种为虚拟机自带的类加载器。</p><ul><li><strong>启动类加载器(BootstrapClassLoader)</strong>:加载<code>&lt;JAVA_HOME&gt;\jre\lib\rt.jar</code>中的class。</li><li><strong>扩展类加载器(ExtClassLoader)</strong>:加载<code>&lt;JAVA_HOME&gt;\jre\lib\ext</code>下的类库。</li><li><strong>应用类加载器(AppClassLoader)</strong>:也被称为系统类加载器，负责加载<code>classpath</code>中指定的jar包及目录中class。</li><li><strong>自定义类加载器(<code>Java.lang.ClassLoader</code>的子类)</strong>:用户可以定制类的加载方式。</li></ul><p><strong>三者之间的关系</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">AppClassLoader的父加载器是ExtClassLoader<br>ExtClassLoader的父加载器是Bootstrap<br>Bootstrap是根加载器<br><br>三者之间是没有继承关系的。<br></code></pre></td></tr></table></figure><p><strong>类加载器工作过程</strong>：当AppClassLoader加载类时，会委派给父类加载器ExtClassLoader，而ExtClassLoader同样不会自己去尝试加载这个类，是委派给BootStrapClassLoader去加载，如果BootStrapClassLoader加载失败，则会交给ExtClassLoader加载，如果ExtClassLoader加载失败再交给AppClassLoader加载，如果AppClassLoader加载失败，则会抛出ClassNotFoundException。</p><p>这就是双亲委派模型，就是当类加载器收到类加载请求时不会自己去尝试加载这个类，首先会将加载请求委派给父类加载器去完成，依次向上，如果不能完成加载再依次向下。</p><p><font color="blue"> 为什么要使用双亲委派模型，有什么好处？</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">避免类的重复加载，确保类的全局唯一性，提高程序的安全性。<br>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 <br></code></pre></td></tr></table></figure><p><font color="blue"> 双亲委派机制是否可被破坏的? </font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，所以双亲委派模型也是可以被破坏的。<br>IBM 公司主导的 JSR-291(即 OSGiR4.2 ) 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi 中称为 Bundle )都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在OSGi 环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。<br>注意：由不同 ClassLoader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 ClassLoader 加载同一个类，在虚拟机内部，会认为这2个类是完全不同的，根据这个特点，可以用来模拟热替换的实现。<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>方法区是JVM的规范，是所有虚拟机都需要遵守的，永久代则是HotSpot虚拟机基于JVM规范对于方法区的落地实现，并且只有HotSpot虚拟机才有永久代。永久代在JDK8被移除。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>元空间是JDK8及之后，废弃了永久代之后HotSpot虚拟机堆方法区的新的落地实现。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>类型为基本类型或者并且被赋值时只能使用字面量而不是方法的形式。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JVM/" class="category-chain-item">JVM</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%BA%95%E5%B1%82/">#底层</a> <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a></div></div><div class="license-box my-3"><div class="license-title"><div>JVM-1:JVM整体结构以及类加载器</div><div>http://www.hff.ink/2023/04/08/jvm总结-1/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>hff</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年4月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2023/03/15/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" title="使用Hexo在GithubPages上搭建一个简易的博客"><span class="hidden-mobile">使用Hexo在GithubPages上搭建一个简易的博客</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <span>备案证书</span> <a href="https://beian.miit.gov.cn/" target="_blank">陇ICP备2023000632号</a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>