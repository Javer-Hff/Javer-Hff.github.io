<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM-1:JVM整体结构以及类加载器</title>
    <link href="/2023/04/08/jvm%E6%80%BB%E7%BB%93-1/"/>
    <url>/2023/04/08/jvm%E6%80%BB%E7%BB%93-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>对于Java程序员来说，JAVA虚拟机底层的指令，不是我们核心关注的内容，我们关注的是我们写的java程序在jvm中运行时需要的内存，内存是由JVM自动管理的，由于程序或硬件的原因可能会出现内存泄漏或溢出的问题导致运行的程序崩溃，不了解JVM的内存结构和各个内存区域的工作职责，将对解决这类问题带来很大的麻烦，所以学习java到一定程度的时候，是必须要学习jvm里的知识点的</p><p>关于JVM，其实有很多大厂开发了不同版本的JVM，比较知名的有：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、 Azul VM、 Apache Harmony、 Google Dalvik VM、 Microsoft JVM等等。</p><p>现在使用的比较多的JDK8版本就是Sun HotSpot VM与BEA JRockit VM合并之后开发出的JDK版本。</p><p>JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。所以，JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE，JRE又包含了JVM。</p>          </div><h2 id="jvm的整体结构">jvm的整体结构</h2><pre><code class=" mermaid">flowchart TD    subgraph &quot; &quot;        direction LR            f[CLass files] --&gt; c[Class Loader]    end        subgraph runtime [运行时数据区]        subgraph private [线程共享]        method[方法区]            stack[堆]         end        subgraph public[线程私有]            heap[栈]             native[本地方法栈]            count[程序计数器]        end    end    subgraph a[ ]        direction LR            subgraph 执行引擎                解释器                subgraph JIT编译器                    中间代码生成器                    代码优化器                    目标代码生成器                    分析器                end                垃圾回收器            end                       subgraph 本地方法接口                JNI            end                        subgraph 本地方法库                NativeMethodLibrary            end            执行引擎&lt;--&gt;本地方法接口            本地方法接口&lt;--&gt;本地方法库    end    c--&gt;runtime    runtime &lt;--&gt; a</code></pre><h3 id="运行时数据区">运行时数据区</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><h4 id="线程共享">线程共享</h4><h5 id="方法区">方法区</h5><p>存放类的元数据(类，接口，属性，方法…)，<strong>静态变量+常量+类信息(构造方法/接口定义)+运行时常量池</strong>存在方法区中但是<strong>实例变量存在堆内存</strong>中,和方法区无关。</p><ul><li><strong>常量池</strong>：常量池是方法区的一部分，Class文件中除了类的基本信息还有类的常量池表，用于存放编译期生成的字面量与符号引用，这些内容将被加载到常量池中。</li></ul><h5 id="堆">堆</h5><p>存放对象实例，new出来的对象都会在堆中分配内存，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法</strong>都是在函数的栈内存中分配。</p><h4 id="线程私有">线程私有</h4><h5 id="栈-虚拟机栈">栈(虚拟机栈)</h5><p>描述Java方法执行的线程内存模型，每个方法被执行时，虚拟机都会同步创建一个栈帧<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。每一个方法被调用直至执行结束，都对应一个栈帧出栈到入栈的过程。</p><p>栈又分为三个子实体：</p><ul><li><p><strong>局部变量表</strong> —— 与方法相关，涉及局部变量，并在此存储相应的值。</p></li><li><p><strong>操作数栈</strong> —— 如果需要执行任何中间操作，操作数栈将充当运行时工作空间来执行操作。</p></li><li><p><strong>帧数据</strong> —— 对应于方法的所有符号存储在此处。在任何异常的情况下，捕获的区块信息将被保持在帧数据中。</p></li></ul><h5 id="本地方法栈">本地方法栈</h5><p>本地方法栈的作用与虚拟机栈的作用类似，不同的是本地方法栈是为本地方法所服务，它的具体做法是<code>本地方法栈中</code>登记为<code>本地方法</code>，在<code>执行引擎</code>执行时加载<code>本地方法库</code>。</p><h5 id="程序计数器">程序计数器</h5><p>当前线程执行的字节码的行号指示器，就是一个指针。字节码解释器工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理和线程恢复等功能都依赖于它来完成，是一个非常小的内存空间，几乎可以忽略不记。</p><h3 id="执行引擎">执行引擎</h3><p>分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐个执行它。</p><ul><li><p><strong>解释器</strong>：读取字节码，对其进行解释并逐一执行。解释器解释字节码的速度较快，但执行速度较慢。解释器的缺点是，当一个方法多次调用时，每次都需要解释。</p></li><li><p><strong>JIT编译器</strong>：JIT编译器消除了解释器的缺点（当一个方法多次调用时，每次都需要解释），执行引擎将使用解释器的帮助进行转换，当发现重复的代码时，它将使用JIT编译器编译整个字节码并将其更改为本地代码。此本地代码将直接用于重复的方法调用，从而提高系统性能。</p><ul><li>中间代码生成器 —— 生成中间代码。</li><li>代码优化器 —— 代码优化器负责优化上面生成的中间代码。</li><li>目标代码生成器 —— 目标代码生成器负责生成机器代码/本机代码。</li><li>分析器 —— 一个特殊组件，负责查找热点，即该方法是否被多次调用。</li></ul></li><li><p><strong>垃圾回收器</strong>：垃圾回收器是执行引擎的一部分，它收集/删除未引用的对象。可以通过调用<code>System.gc()</code>来触发垃圾回收，但是不能保证执行。JVM的垃圾收集器仅收集那些由new关键字创建的对象（无论以哪种方式创建对象，最终也是会回到new关键字上，只是不是我们显式地使用关键字new创建而已）。因此，如果创建了没有new的任何对象，则可以使用<code>finalize</code>方法执行清理。</p></li></ul><h3 id="本地方法接口">本地方法接口</h3><p>本地方法接口(JNI)将与本机方法库进行交互，并提供执行引擎所需的本机库。</p><h3 id="本地方法库">本地方法库</h3><p>它是执行引擎所需的本机库的集合。</p><p><font color="blue">JDK1.7和JDK1.8的运行时数据区的区别？（永久代<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和元空间<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>）</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">JDK1.8以前的HotSpot JVM有方法区，也叫永久代(permanent generation,PermGen space,PermGen)。<br>    <br>方法区用于存放已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码。<br>    <br>方法区是一片连续的堆空间，通过-XX:MaxPermSize来设定永久代最大可分配空间，当JVM加载的类信息容量超过了这个值，会报OOM:PermGen错误。<br>    <br>永久代的GC是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集。<br>    <br>移除永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)、类的静态变量转移到了Java heap。<br>    <br>JDK1.8 和 JDK1.7的jvm内存最大的区别是：在1.8中方法区是由元空间(元数据区)来实现的，常量池移到堆中。1.8不存在方法区，将方法区的实现给去掉了，而是在本地内存中,新加入元数据区(元空间)。<br>    <br>元空间：存储 .class 信息， 类的信息，方法的定义，静态变量等，而常量池放到堆里存储。<br><br>JDK8时，永久代已被移除，所以不支持 -XX:PermSize=10M -XX:MaxPermSize=10M 永久代的参数设置。<br>JDK8 的方法区是 元空间，其参数设置是 -XX:MetaspaceSize=N -XX:MaxMetaspaceSize=N。<br><br>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用 本地内存。默认情况下，元空间的大小仅受 本地内存 限制，但可以通过参数来指定元空间的大小。<br></code></pre></td></tr></table></figure><p><font color="blue">为什么要用元空间替代方法区？</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中就容易出现内存溢出，设置大了又浪费内存。<br></code></pre></td></tr></table></figure><h2 id="类加载器ClassLoader">类加载器ClassLoader</h2><h3 id="类的加载过程">类的加载过程</h3><pre><code class=" mermaid">flowchart TDsubgraph 连接Linking验证Verification--&gt;准备Preparation--&gt;解析Resolutionend加载Loading--&gt;连接Linking--&gt;初始化Initialization--&gt;使用Using--&gt;卸载Unloading</code></pre><p>类加载过程包括：加载，连接，初始化，使用和卸载，其中连接阶段又可以分为验证，准备和解析。这其中除了解析阶段，其他阶段的顺序都是固定的，解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定(动态绑定)，以此实现Java的继承和多态。</p><h4 id="加载">加载</h4><p>加载阶段是将<code>.class</code>文件加载到<code>classLoader</code>中，并创建一个<code>Class</code>对象。</p><p>在加载阶段，jvm需要做以下三件事情：</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的的静态存储结构转换为方法区的运行时数据结构</li><li>在堆内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的访问入口。</li></ul><h4 id="验证">验证</h4><p>此时文件字节流已经被获取到，需要将<code>.class</code>文件中的类数据转换为方法区的运行时数据结构，但是先需要验证文件中信息是否符合当前虚拟机规范。按照虚拟机规范，如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个<code>java.lang.VerifyError</code>异常或其子类异常。</p><h4 id="准备">准备</h4><p>为类的静态变量分配内存空间，并且初始化为默认值。而如果变量被<code>final static</code>修饰，并且类型<code>ConstantValue</code><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>时，在准备阶段就将变量设置成该值。而<code>final</code>单独修饰的变量则在初始化时进行赋值。</p><h4 id="解析">解析</h4><p>解析阶段是将常量池中符号引用替换为直接引用的过程，根据符号引用的信息，在类或接口的运行时常量池中查找对应的直接引用，如果直接引用不存在，则需要通过其他方式生成直接引用，比如类或者接口的初始化方法，或者父类父接口的初始化方法。</p><h4 id="初始化">初始化</h4><p>这是类加载的最后阶段，此处所有静态变量将被分配原始值，并且将执行静态块。</p><p><font color='blue'> 父类和子类的初始化顺序？ </font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">父类静态块→子类静态块→父类初始化块（成员变量，非静态代码块等）→父类构造方法→子类初始化块（成员变量，非静态代码块等）→子类构造方法<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><p>这里类加载完成之后就可以进行使用了，上面说到的都是静态变量，代码块的初始化赋值执行操作，那么类的成员变量，类的构造方法呢？这些叫做<code>init</code>方法执行构造方法，完成类成员变量的初始化（也就是实例变量），当然这些都是在创建完对象后进行的操作，而且<code>init</code>执行前需要显示的去执行父类的<code>init</code>方法。</p><h4 id="卸载">卸载</h4><p>类型卸载的条件比较严苛，具备以下条件的类才可以被卸载</p><ul><li>该类的所有对象都已被清除。</li><li>该类的<code>java.lang.Class</code>对象没有被任何对象或变量引用。只要一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：<code>java.lang.Class</code>。这个对象在类被加载进方法区的时候创建，在方法区中该类被删除时清除。</li><li>加载该类的<code>ClassLoader</code>已经被回收。</li></ul><h3 id="双亲委派模型">双亲委派模型</h3><p>Java中的类加载器分为四种，前三种为虚拟机自带的类加载器。</p><ul><li><strong>启动类加载器(BootstrapClassLoader)</strong>:加载<code>&lt;JAVA_HOME&gt;\jre\lib\rt.jar</code>中的class。</li><li><strong>扩展类加载器(ExtClassLoader)</strong>:加载<code>&lt;JAVA_HOME&gt;\jre\lib\ext</code>下的类库。</li><li><strong>应用类加载器(AppClassLoader)</strong>:也被称为系统类加载器，负责加载<code>classpath</code>中指定的jar包及目录中class。</li><li><strong>自定义类加载器(<code>Java.lang.ClassLoader</code>的子类)</strong>:用户可以定制类的加载方式。</li></ul><p><strong>三者之间的关系</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">AppClassLoader的父加载器是ExtClassLoader<br>ExtClassLoader的父加载器是Bootstrap<br>Bootstrap是根加载器<br><br>三者之间是没有继承关系的。<br></code></pre></td></tr></table></figure><p><strong>类加载器工作过程</strong>：当AppClassLoader加载类时，会委派给父类加载器ExtClassLoader，而ExtClassLoader同样不会自己去尝试加载这个类，是委派给BootStrapClassLoader去加载，如果BootStrapClassLoader加载失败，则会交给ExtClassLoader加载，如果ExtClassLoader加载失败再交给AppClassLoader加载，如果AppClassLoader加载失败，则会抛出ClassNotFoundException。</p><p>这就是双亲委派模型，就是当类加载器收到类加载请求时不会自己去尝试加载这个类，首先会将加载请求委派给父类加载器去完成，依次向上，如果不能完成加载再依次向下。</p><p><font color='blue'> 为什么要使用双亲委派模型，有什么好处？ </font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">避免类的重复加载，确保类的全局唯一性，提高程序的安全性。<br>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 <br></code></pre></td></tr></table></figure><p><font color='blue'> 双亲委派机制是否可被破坏的? </font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，所以双亲委派模型也是可以被破坏的。<br>IBM 公司主导的 JSR-291(即 OSGiR4.2 ) 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi 中称为 Bundle )都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在OSGi 环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。<br>注意：由不同 ClassLoader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 ClassLoader 加载同一个类，在虚拟机内部，会认为这2个类是完全不同的，根据这个特点，可以用来模拟热替换的实现。<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>用于存储局部变量表，操作数栈，动态链接，方法出口等信息。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>方法区是JVM的规范，是所有虚拟机都需要遵守的，永久代则是HotSpot虚拟机基于JVM规范对于方法区的落地实现，并且只有HotSpot虚拟机才有永久代。永久代在JDK8被移除。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>元空间是JDK8及之后，废弃了永久代之后HotSpot虚拟机堆方法区的新的落地实现。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>类型为基本类型或者并且被赋值时只能使用字面量而不是方法的形式。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>底层</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo在GithubPages上搭建一个简易的博客</title>
    <link href="/2023/03/15/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/15/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>一个关于Hexo简单的 quickStart ，Hexo的可玩性很高，还有很多功能可以发掘，本篇文章只是一个简单的入门案例</p>          </div><h2 id="安装环境">安装环境</h2><ul><li><p>Git</p></li><li><p>github账号</p></li><li><p>nodeJs 10.13+</p></li></ul><h2 id="Hexo安装及简单配置">Hexo安装及简单配置</h2><h4 id="1-安装hexo">1.安装hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h4 id="2-初始化项目">2.初始化项目</h4><p>hexo 常用命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo -g <span class="hljs-comment">#安装Hexo</span><br>npm update hexo -g <span class="hljs-comment">#升级</span><br>hexo init <span class="hljs-comment">#初始化博客</span><br><br><span class="hljs-comment">#命令简写</span><br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo new <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-comment">#新建文章</span><br>hexo g == hexo generate <span class="hljs-comment">#生成</span><br>hexo s == hexo server <span class="hljs-comment">#启动服务预览</span><br>hexo d == hexo deploy <span class="hljs-comment">#部署</span><br><br>hexo server <span class="hljs-comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span><br>hexo server -s <span class="hljs-comment">#静态模式</span><br>hexo server -p 5000 <span class="hljs-comment">#更改端口</span><br>hexo server -i 192.168.1.1 <span class="hljs-comment">#自定义 IP</span><br>hexo clean <span class="hljs-comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span><br></code></pre></td></tr></table></figure><p>安装 hexo-cli 完成后,新建一个文件夹来作为你的博客项目的Home,在文件夹内执行以下命令来初始化你的hexo博客。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init<br></code></pre></td></tr></table></figure><p>新建完成后，文件目录如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>├── _config.yml <span class="hljs-meta">#hexo配置文件</span><br>├── package.json <span class="hljs-meta">#nodejs打包配置</span><br>├── scaffolds <span class="hljs-meta">#模板文件夹</span><br>├── source<span class="hljs-meta">#资源文件夹</span><br><span class="hljs-string">|   ├── _drafts</span><br><span class="hljs-string">|   └── _posts</span><br>└── themes <span class="hljs-meta">#主题文件夹</span><br></code></pre></td></tr></table></figure><p>初始化完成后即可使用以下命令在本地运行项目预览</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo server<br></code></pre></td></tr></table></figure><h4 id="3-hexo项目结构">3.hexo项目结构</h4><h5 id="config-yml">_config.yml</h5><p>hexo的核心配置文件，是整个博客网站的配置文件。</p><p>详细配置参数参考<a href="https://hexo.io/zh-cn/docs/configuration">这里</a></p><h5 id="scaffolds">scaffolds</h5><p>模板文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>执行这行命令，hexo就会在我们的scaffolds问价夹下找photo.md并根据其中的模板来生成source/_photo/My Gallery.md文件作为我们的一篇博客。</p><p>当我们使用hexo命令生成文章时，就会将模板中的内容复制到我们新建的文章中。</p><p>以下是post.md的内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>hexo new命令默认使用post.md模板，当我们使用<code>hexo new blog</code>时，会自动在blog.md文章的顶部加上post.md中的内容</p><p>关于模板的详细配置参考<a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">这里</a></p><h5 id="source">source</h5><p>资源文件夹，一般用来存放常用的静态资源。我们生成的markdown文档也都存放在这里。</p><p>以下时官方文档中的解释:</p><blockquote><p>除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></blockquote><h5 id="themes">themes</h5><p>主题文件夹,会在下面安装主题时介绍。</p><h4 id="4-创建博客">4.创建博客</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new [模板] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>如本篇文章使用的命令就是<code>hexo new Hexo博客搭建</code> ，此时source文件夹目录如下(因为配置的render_drafts=false，所以没有drafts文件夹)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">├── _posts<br><span class="hljs-string">|   └── Hexo博客搭建.md</span><br></code></pre></td></tr></table></figure><h4 id="5-主题配置">5.主题配置</h4><p>hexo官网提供了丰富的主题，官方的主题下载地址在<a href="https://hexo.io/themes/">这里</a></p><p>这里以本博客的主题<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>为例，<strong>具体其他主题请参阅相关主题的文档</strong></p><p>这里博主使用的hexo版本是6.3.0，根据Fluid的官方文档，不需要在手动下载模板源码，可以使用npm直接安装即可，hexo版本低的同学可以参考<a href="https://hexo.fluid-dev.com/docs/start/#%E6%90%AD%E5%BB%BA-hexo-%E5%8D%9A%E5%AE%A2">Fluid的官方文档</a>进行配置。</p><p>在博客项目的根目录下执行以下命令，安装Fluid模板</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客的根目录下创建<code>_config.fluid.yml</code>,将<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">Fluid官方示例中的配置文件</a>复制进去</p><p>Fluid项目在GitHub上的配置文件，其中都有很详细的中文注释，大家根据自己的需求修改即可</p><p>修改Hexo的配置文件<code>_config.yml</code>来使Fluid主题生效</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>退出hexo服务器重新运行<code>hexo server</code>刷新浏览器即可看到主题生效</p><h2 id="部署到GithubPages">部署到GithubPages</h2><ol><li><p>创建<code>&lt;GitHub 用户名&gt;.github.io</code>仓库来存放博客的静态页面(<strong>GitHub 用户名替换为你自己的GitHub用户名</strong>)</p></li><li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。<code>npm install hexo-deployer-git --save</code></p></li><li><p>在 <code>_config.yml</code> 中添加以下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-comment">#类型</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-comment">#仓库地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-comment">#分支</span><br></code></pre></td></tr></table></figure></li><li><p>执行命令<code>hexo clean &amp;&amp; hexo deploy</code></p></li><li><p>浏览 <code>&lt;GitHub 用户名&gt;.github.io</code> 检查你的网站能否运作。</p></li><li><p>[^在修改文章或添加静态资源后使用<code>hexo g</code>来生成静态资源到html再使用<code>hexo d</code>部署到GitHubPages上去，否则，静态资源没有生成页面没有更新]</p></li></ol><p>此处的配置仓库地址使用的时https地址，也可以配置为ssh地址，具体使用可以参考<a href="https://docs.github.com/zh/pages">GithubPages</a>和<a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>的文档</p><h2 id="参考资料">参考资料</h2><p>Fluid 一款 Material Design 风格的 Hexo 博客主题：<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p><p>Hexo 快速、简洁且高效的博客框架：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h2 id="一些示例">一些示例</h2><p><a href="https://akilar.top/">akilarの糖果屋</a></p><p><a href="http://kenjiendo.com/">KENJI ENDO</a></p><p><a href="https://www.strml.net/">STRML</a></p><p><a href="https://lruihao.github.io/">李瑞豪的博客</a></p><p><a href="https://tangly1024.com/">TANGLY’s BLOG</a></p><p><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></p><p><a href="https://www.codesky.me/">CodeSky</a></p><p><a href="https://kaitohh.com/">KaitoHH</a></p><p><a href="https://diygod.me/">DIYGod</a></p><p><a href="https://blog.aoaostar.com/">Pluto</a></p><p><a href="https://halfrost.com/">冰霜之地</a></p><p>更多优秀博客可以参阅Github上的<a href="https://github.com/timqian/chinese-independent-blogs">chinese-independent-blogs</a>项目</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
